shader FuseCoreTexture: FuseCoreMath, Texturing, ShaderUtils
{

	////////////////////////////////////////////////////////////////
	//
	//          UV Mapping functions
	// 			
	////////////////////////////////////////////////////////////////

	#ifndef TWOPI
	#define TWOPI 6.28318531
	#endif

	#ifndef PI
	#define PI 3.14159265
	#endif

	// Cubemap to BoxGrid - UV based conversion for Fuse
	// Takes UV coordinates and converts to cubemap direction for boxgrid layout

	// Function to convert UV to cubemap direction for horizontal strip layout
	// Layout: +X, -X, +Y, -Y, +Z, -Z
	float3 BoxgridUVToDirection_HorizontalStrip(float2 uv)
	{
		// Determine which face we're on (0-5)
		float faceWidth = 1.0 / 6.0;
		int faceIndex = int(uv.x / faceWidth);
		
		// Get UV within the face [0,1]
		float2 faceUV = float2((uv.x - faceIndex * faceWidth) / faceWidth, uv.y);
		
		// Convert from [0,1] to [-1,1]
		float2 faceCoord = faceUV * 2.0 - 1.0;
		
		// Generate direction based on face
		float3 direction = float3(0, 0, 0);
		
		switch(faceIndex)
		{
			case 0: // +X
				direction = float3(1.0, -faceCoord.y, -faceCoord.x);
				break;
			case 1: // -X
				direction = float3(-1.0, -faceCoord.y, faceCoord.x);
				break;
			case 2: // +Y
				direction = float3(faceCoord.x, 1.0, faceCoord.y);
				break;
			case 3: // -Y
				direction = float3(faceCoord.x, -1.0, -faceCoord.y);
				break;
			case 4: // +Z
				direction = float3(faceCoord.x, -faceCoord.y, 1.0);
				break;
			case 5: // -Z
				direction = float3(-faceCoord.x, -faceCoord.y, -1.0);
				break;
		}
		
		return normalize(direction);
	}

	float2 DirectionToBoxgridUV_Horizontal(float3 dir)
	{
		float3 absDir = abs(dir);
		float maxAxis = max(absDir.x, max(absDir.y, absDir.z));
		
		int faceIndex;
		float2 faceCoord;
		
		if (maxAxis == absDir.x)
		{
			if (dir.x > 0) // +X face
			{
				faceIndex = 0;
				faceCoord = float2(-dir.z / dir.x, -dir.y / dir.x);
			}
			else // -X face
			{
				faceIndex = 1;
				faceCoord = float2(dir.z / -dir.x, -dir.y / -dir.x);
			}
		}
		else if (maxAxis == absDir.y)
		{
			if (dir.y > 0) // +Y face
			{
				faceIndex = 2;
				faceCoord = float2(dir.x / dir.y, dir.z / dir.y);
			}
			else // -Y face
			{
				faceIndex = 3;
				faceCoord = float2(dir.x / -dir.y, -dir.z / -dir.y);
			}
		}
		else // maxAxis == absDir.z
		{
			if (dir.z > 0) // +Z face
			{
				faceIndex = 4;
				faceCoord = float2(dir.x / dir.z, -dir.y / dir.z);
			}
			else // -Z face
			{
				faceIndex = 5;
				faceCoord = float2(-dir.x / -dir.z, -dir.y / -dir.z);
			}
		}
		
		// Convert face coordinates from [-1,1] to [0,1]
		float2 cellUV = (faceCoord + 1.0) * 0.5;
		
		// Convert to grid UV
		float faceWidth = 1.0 / 6.0;
		float2 gridUV = float2(faceIndex * faceWidth + cellUV.x * faceWidth, cellUV.y);
		
		return gridUV;
	}

	// Function for 3x2 grid layout
	// Top row: +X, -X, +Y
	// Bottom row: -Y, +Z, -Z
	float3 BoxgridUVToDirection_3x2Grid(float2 uv)
	{
		float faceWidth = 1.0 / 3.0;
		float faceHeight = 1.0 / 2.0;
		
		int col = int(uv.x / faceWidth);
		int row = int(uv.y / faceHeight);
		int faceIndex = row * 3 + col;
		
		// Remap face indices for 3x2 layout
		int faceRemap[6] = {0, 1, 2, 3, 4, 5};
		if (row == 0) // Top row
		{
			if (col == 0) faceIndex = 0; // +X
			else if (col == 1) faceIndex = 1; // -X
			else faceIndex = 2; // +Y
		}
		else // Bottom row
		{
			if (col == 0) faceIndex = 3; // -Y
			else if (col == 1) faceIndex = 4; // +Z
			else faceIndex = 5; // -Z
		}
		
		// Get UV within the face
		float2 faceUV = float2((uv.x - col * faceWidth) / faceWidth, 
							(uv.y - row * faceHeight) / faceHeight);
		
		// Convert to [-1, 1]
		float2 faceCoord = faceUV * 2.0 - 1.0;
		
		// Generate direction based on face
		float3 direction = float3(0, 0, 0);
		
		switch(faceIndex)
		{
			case 0: // +X
				direction = float3(1.0, -faceCoord.y, -faceCoord.x);
				break;
			case 1: // -X
				direction = float3(-1.0, -faceCoord.y, faceCoord.x);
				break;
			case 2: // +Y
				direction = float3(faceCoord.x, 1.0, faceCoord.y);
				break;
			case 3: // -Y
				direction = float3(faceCoord.x, -1.0, -faceCoord.y);
				break;
			case 4: // +Z
				direction = float3(faceCoord.x, -faceCoord.y, 1.0);
				break;
			case 5: // -Z
				direction = float3(-faceCoord.x, -faceCoord.y, -1.0);
				break;
		}
		
		return normalize(direction);
	}

	float2 DirectionToBoxgridUV_3x2(float3 dir)
	{
		float3 absDir = abs(dir);
		float maxAxis = max(absDir.x, max(absDir.y, absDir.z));
		
		int row, col;
		float2 faceCoord;
		
		if (maxAxis == absDir.x)
		{
			if (dir.x > 0) // +X face
			{
				row = 0; col = 0;
				faceCoord = float2(-dir.z / dir.x, -dir.y / dir.x);
			}
			else // -X face
			{
				row = 1; col = 0;
				faceCoord = float2(dir.z / -dir.x, -dir.y / -dir.x);
			}
		}
		else if (maxAxis == absDir.y)
		{
			if (dir.y > 0) // +Y face
			{
				row = 0; col = 1;
				faceCoord = float2(dir.x / dir.y, dir.z / dir.y);
			}
			else // -Y face
			{
				row = 1; col = 1;
				faceCoord = float2(dir.x / -dir.y, -dir.z / -dir.y);
			}
		}
		else // maxAxis == absDir.z
		{
			if (dir.z > 0) // +Z face
			{
				row = 0; col = 2;
				faceCoord = float2(dir.x / dir.z, -dir.y / dir.z);
			}
			else // -Z face
			{
				row = 1; col = 2;
				faceCoord = float2(-dir.x / -dir.z, -dir.y / -dir.z);
			}
		}
		
		// Convert face coordinates from [-1,1] to [0,1]
		float2 cellUV = (faceCoord + 1.0) * 0.5;
		
		// Convert to grid UV
		float faceWidth = 1.0 / 3.0;
		float faceHeight = 1.0 / 2.0;
		
		float2 gridUV = float2(col * faceWidth + cellUV.x * faceWidth,
							row * faceHeight + cellUV.y * faceHeight);
		
		return gridUV;
	}

	// Function for cross/unfolded cube layout
	//     [+Y]
	// [-X][+Z][+X][-Z]
	//     [-Y]
	float3 BoxgridUVToDirection_Cross(float2 uv)
	{
		// 4x3 grid layout
		float faceWidth = 1.0 / 4.0;
		float faceHeight = 1.0 / 3.0;
		
		// Get grid position
		int col = int(uv.x / faceWidth);
		int row = int(uv.y / faceHeight);
		
		// Get UV within the current cell [0,1]
		float2 cellUV = float2((uv.x - col * faceWidth) / faceWidth,
							(uv.y - row * faceHeight) / faceHeight);
		
		// Convert to [-1,1] for face coordinates
		float2 faceCoord = cellUV * 2.0 - 1.0;
		
		float3 direction = float3(0, 0, 0);
		
		// Apply your specific mappings and rotations
		if (row == 0) // Top row
		{
			if (col == 1) // +Y face (was at 1,0, should stay at 1,0)
			{
				// +Y face - looking down
				direction = float3(faceCoord.x, -faceCoord.y, 1.0);
			}
		}
		else if (row == 1) // Middle row
		{
			if (col == 0) // -X face (needs 90° CCW rotation)
			{
				// Rotate 90 degrees counter-clockwise
				float2 rotated = float2(-faceCoord.y, faceCoord.x);
				direction = float3(-1.0, -rotated.y, rotated.x);
			}
			else if (col == 1) // +Z face (was at 1,1, should be from 0,1)
			{
				// +Z face - looking backward
				direction = float3(faceCoord.x, -1.0, -faceCoord.y);
			}
			else if (col == 2) // +X face (needs 90° CW rotation)
			{
				// Rotate 90 degrees clockwise
				float2 rotated = float2(faceCoord.y, -faceCoord.x);
				direction = float3(1.0, -rotated.y, -rotated.x);
			}
			else if (col == 3) // -Z face (needs 180° rotation, was at 1,3, should be from 2,1)
			{
				direction = float3(faceCoord.x, 1.0, faceCoord.y);
			}
		}
		else if (row == 2) // Bottom row
		{
			if (col == 1) 
			{
				float2 rotated = float2(-faceCoord.x, -faceCoord.y);
				direction = float3(-rotated.x, -rotated.y, -1.0);
			}
		}
		
		// Only normalize if we have a valid direction
		if (dot(direction, direction) > 0.1)
			return normalize(direction);
		else
			return float3(0, 0, 0);
	}

	float2 DirectionToBoxgridUV_Cross(float3 dir)
	{
		float3 absDir = abs(dir);
		float maxAxis = max(absDir.x, max(absDir.y, absDir.z));
		
		int row, col;
		float2 faceCoord;
		
		if (maxAxis == absDir.y)
		{
			if (dir.y > 0) // +Y face
			{
				row = 1; col = 3;
				faceCoord = float2(dir.x / -dir.y, dir.z / dir.y);
			}
			else // -Y face
			{
				row = 1; col = 1;
				faceCoord = float2(-dir.x / -dir.y, -dir.z / -dir.y);
			}
		}
		else if (maxAxis == absDir.x)
		{
			if (dir.x > 0) // +X face
			{
				row = 1; col = 0;
				// Apply inverse 90° CW rotation
				float2 temp = float2(-dir.z / dir.x, dir.y / dir.x);
				faceCoord = float2(-temp.y, temp.x);
			}
			else // -X face
			{
				row = 1; col = 2;
				// Apply inverse 90° CCW rotation
				float2 temp = float2(dir.z / -dir.x, dir.y / -dir.x);
				faceCoord = float2(temp.y, -temp.x);
			}
		}
		else // maxAxis == absDir.z
		{
			if (dir.z > 0) // +Z face
			{
				row = 0; col = 1;
				faceCoord = float2(dir.x / -dir.z, -dir.y / dir.z);
			}
			else // -Z face
			{
				row = 2; col = 1;
				faceCoord = float2(dir.x / dir.z, dir.y / -dir.z);
			}
		}
		
		// Convert face coordinates from [-1,1] to [0,1]
		float2 cellUV = (faceCoord + 1.0) * 0.5;
		
		// Convert to grid UV
		float faceWidth = 1.0 / 4.0;
		float faceHeight = 1.0 / 3.0;
		
		float2 gridUV = float2(col * faceWidth + cellUV.x * faceWidth,
							row * faceHeight + cellUV.y * faceHeight);
		
		return gridUV;
	}																	

	// Convert equirectangular UV to 3D direction
	float3 EquirectangularUVToDirection(float2 uv)
	{
		// Convert UV to spherical coordinates
		float theta = uv.x * 2.0 * 3.14159265359; // Longitude: 0 to 2π
		float phi = uv.y * 3.14159265359;          // Latitude: 0 to π
		
		// Convert spherical to Cartesian coordinates
		float sinPhi = sin(phi);
		float3 direction = float3(
			sinPhi * cos(theta),  // x
			cos(phi),             // y
			sinPhi * sin(theta)   // z
		);
		
		return normalize(direction);
	}

	float2 cubicUV(float3 pos, float3 norm)
	{
		norm = float3(abs(norm.x), abs(norm.y), abs(norm.z));

		if (norm.x > norm.y && norm.x > norm.z) //project on x axis
		return float2(pos.z, -pos.y)+.5;

		else if (norm.y > norm.x && norm.y > norm.z) //project on y axis
		return float2(pos.x, -pos.z)+.5;

		else return float2(pos.x, -pos.y)+.5; // project on z axis
	};

	float2 sphericalUV(float3 norm)
	{ 
		float2 result;
		float r;
		r = norm.x * norm.x + norm.y * norm.y + norm.z * norm.z;

		if (r > 0)
		{
			r = sqrt(r);
			float p, y;
			p = asin(norm.y/r) / TWOPI;
			y = 0;
			if (norm.z != 0) y = atan2(-norm.x, -norm.z);
			else if (norm.x > 0) y = -PI / 2;
			 else y = PI / 2;
			y /=  TWOPI;
			result = float2(-y,-(p+.25)*2);		
		}
		else result = 0;
		return result;
	};

	//TODO should use pos+norms
	float2 cylindricalUV(float3 pos)
	{
		float2 uv;
		uv.y = -pos.y-.5;
		if (length(pos) > 0)
		{
			if (pos.z != 0)  uv.x = atan2(pos.x, -pos.z);
			else if (pos.x > 0) uv.x = -PI / 2;
			else uv.x = PI / 2;
			uv.x /=  TWOPI;
		}
		else uv.x = 0;
		return uv;
	};



	// Triplaner Texture mapping
	float4 triPlane(Texture2D tex, SamplerState s, float3 p, float3 n, float scale, float k)
	{
		 p *= scale;
		float3 m = pow( abs( n ), k );
		float4 x = tex.Sample( s, p.yz );
		float4 y = tex.Sample( s, p.zx );
		float4 z = tex.Sample( s, p.xy );
		return (x*m.x + y*m.y + z*m.z) / (m.x + m.y + m.z);
	}

	// Triplaner Texture mapping w/ gradients
	float4 triPlane(Texture2D tex, SamplerState s, float3 p, float3 n, float3 gx, float3 gy, float scale = 1.0, float k = 4.0)
	{
		p *= scale;
		gx *= scale;
		gy *= scale;
		float3 m = pow( abs( n ), k );
		float4 x = tex.SampleGrad(s, p.yz, gx.yz, gy.yz);
		float4 y = tex.SampleGrad(s, p.zx, gx.zx, gy.zx);
		float4 z = tex.SampleGrad(s, p.xy, gx.xy, gy.xy);
		return (x*m.x + y*m.y + z*m.z) / (m.x + m.y + m.z);
	}

	// Pretty sure this is dodgy
	float3 triPlaneNormal(Texture2D tex, SamplerState s, float3 p, float3 n, float scale,  float k)
	{
		p*= scale;
		float3 Tangent1 = normalize(float3(n.x, 1, n.y));
		float3 Tangent2 = normalize(float3(n.y, 1, n.z));
		float3 Tangent3 = normalize(float3(n.z, 1, n.x));
		float3x3 TBN1, TBN2, TBN3;
		TBN1[0] = Tangent1;
		TBN1[1] = cross(n, Tangent1);
		TBN1[2] = n;
		TBN2[0] = Tangent2;
		TBN2[1] = cross(n, Tangent2);
		TBN2[2] = n;
		TBN3[0] = Tangent3;
		TBN3[1] = cross(n, Tangent3);
		TBN3[2] = n;

		float3 m = pow( abs( n ), k );
		float3 n1 = tex.Sample( s, p.yz ).rgb * 2.0 - 1.0;;
		float3 n2 = tex.Sample( s, p.zx ).rgb * 2.0 - 1.0;;
		float3 n3 = tex.Sample( s, p.xy ).rgb * 2.0 - 1.0;;
		// Transform normals into world space
		n1 = mul(n1, TBN1);
		n2 = mul(n2, TBN2);
		n3 = mul(n3, TBN1);
	
		return -normalize((n1*m.x + n2*m.y + n3*m.z) / (m.x + m.y + m.z));
	}


	// Shader code by Inigo Quilez
	//http://www.iquilezles.org/www/articles/texturerepetition/texturerepetition.htm
	float4 sampleNoTile(Texture2D tex, in float2 uv, SamplerState samp, float lod = 0.0 )
	{
		float2 p = floor( uv );
		float2 f = frac( uv );
	
		// voronoi contribution
		float4 va = 0.0;
		float wt = 0.0;
		for( int j=-1; j<=1; j++ )
		for( int i=-1; i<=1; i++ )
		{
			float2 g = float2( float(i), float(j) );
			//float4 o = hash4( p + g );
			// Hash Function
			float2 pg = p + g;
			float4 o = frac(sin(float4( 1.0+dot(pg,float2(37.0,17.0)), 
														2.0+dot(pg,float2(11.0,47.0)),
														3.0+dot(pg,float2(41.0,29.0)),
														4.0+dot(pg,float2(23.0,31.0))))*103.0);
			float2 r = g - f + o.xy;
			float d = dot(r,r);
			float w = exp(-5.0*d );
			float4 c = tex.SampleLevel(samp, uv + o.zw, lod);
			va += w*c;
			wt += w;
		}
		// normalization
		return va/wt;
	}

	float4 sampleGradNoTile(Texture2D tex, in float2 uv, SamplerState samp )
	{
		float2 p = floor( uv );
		float2 f = frac( uv );
	
		// derivatives (for correct mipmapping)
		float2 myddx = ddx( uv );
		float2 myddy = ddy( uv );
	
		// voronoi contribution
		float4 va = 0.0;
		float wt = 0.0;
		for( int j=-1; j<=1; j++ )
		for( int i=-1; i<=1; i++ )
		{
			float2 g = float2( float(i), float(j) );
			//float4 o = hash4( p + g );
			// Hash Function
			float2 pg = p + g;
			float4 o = frac(sin(float4( 1.0+dot(pg,float2(37.0,17.0)), 
														2.0+dot(pg,float2(11.0,47.0)),
														3.0+dot(pg,float2(41.0,29.0)),
														4.0+dot(pg,float2(23.0,31.0))))*103.0);
			float2 r = g - f + o.xy;
			float d = dot(r,r);
			float w = exp(-5.0*d );
			float4 c = tex.SampleGrad( samp, uv + o.zw, myddx, myddy );
			va += w*c;
			wt += w;
		}
		// normalization
		return va/wt;
	}

	// Performs a directional blur based on structural information from a depth map
	// Returns a blurred color that preserves important edges
	float4 DirectionalBlur(
		Texture2D sourceTexture,         // Source image to blur
		Texture2D structureMap,          // Depth/normal map that defines structure
		SamplerState texSampler,         // Sampler state to use
		float2 baseUV,                   // Base texture coordinate
		float blurRadius,                // Radius of the blur (0.0-0.1 recommended)
		float structureInfluence,        // How much structure affects blur direction (0.0-1.0)
		float edgePreservation,          // How much to preserve edges (0.0-10.0)
		float contrastBoost,             // Contrast enhancement (0.0-0.5)
		float saturationBoost,           // Saturation enhancement (0.0-0.5)
		float2 dominantDirection,        // Optional dominant direction to bias blur (normalized)
		float dominantDirectionStrength, // Strength of dominant direction (0.0-1.0)
		float2 texelSize                 // Size of one texel (1.0/width, 1.0/height)
	) {
		// Base color at the original UV
		float4 baseColor = sourceTexture.Sample(texSampler, baseUV);
		
		// Only apply blur if the radius is significant
		if (blurRadius < 0.0001) return baseColor;
		
		// Sample structure (depth/normal) for this position
		float structure = structureMap.Sample(texSampler, baseUV).r;
		
		// Number of samples to take for the blur
		const int sampleCount = 16;
		
		// Accumulate blurred color
		float4 blurredColor = float4(0, 0, 0, 0);
		float totalWeight = 0.0;
		
		// Determine structure gradient
		float2 structureGradient = float2(
			structureMap.Sample(texSampler, baseUV + float2(texelSize.x, 0)).r - 
			structureMap.Sample(texSampler, baseUV - float2(texelSize.x, 0)).r,
			structureMap.Sample(texSampler, baseUV + float2(0, texelSize.y)).r - 
			structureMap.Sample(texSampler, baseUV - float2(0, texelSize.y)).r
		);
		
		// Normalize gradient but keep zero gradients as zero
		float gradientLength = length(structureGradient);
		float2 gradientDir = gradientLength > 0.001 ? normalize(structureGradient) : float2(0, 0);
		
		// Direction perpendicular to gradient (along edges rather than across)
		float2 perpDirection = float2(-gradientDir.y, gradientDir.x);
		
		// Calculate edge strength factor for edge preservation
		float edgeFactor = 1.0 / (1.0 + edgePreservation * gradientLength);
		
		// Apply structure influence to blur radius
		float adjustedRadius = blurRadius * edgeFactor;
		
		// Sample in a directional pattern
		for (int i = 0; i < sampleCount; i++) {
			// Calculate offset angle
			float angle = (float(i) / float(sampleCount)) * 3.14159 * 2.0;
			
			// Create direction vector for this sample
			float2 baseDir = float2(cos(angle), sin(angle));
			
			// Blend between circular pattern and structure-guided pattern
			float2 structureDir = lerp(baseDir, perpDirection, structureInfluence * smoothstep(0.0, 0.05, gradientLength));
			
			// Add influence from dominant direction if specified
			float2 finalDir = normalize(lerp(structureDir, dominantDirection, dominantDirectionStrength));
			
			// Calculate sample offset
			float offset = (float(i) / float(sampleCount - 1) - 0.5) * 2.0; // Range -1 to 1
			float2 sampleOffset = finalDir * offset * adjustedRadius;
			float2 sampleUV = baseUV + sampleOffset;
			
			// Get color at sample position
			float4 sampleColor = sourceTexture.Sample(texSampler, sampleUV);
			
			// Weight based on distance and structure similarity
			float structureAtSample = structureMap.Sample(texSampler, sampleUV).r;
			float structureDiff = abs(structure - structureAtSample);
			
			// Gaussian-like falloff based on distance
			float distanceFactor = exp(-offset * offset * 2.0);
			
			// Structure similarity weight
			float structureWeight = 1.0 / (1.0 + structureDiff * edgePreservation * 10.0);
			
			// Combined weight
			float weight = distanceFactor * structureWeight;
			
			// Accumulate weighted sample
			blurredColor += sampleColor * weight;
			totalWeight += weight;
		}
		
		// Normalize the accumulated color
		float4 resultColor = totalWeight > 0.0 ? blurredColor / totalWeight : baseColor;
		
		// Optional: Enhance contrast and saturation
		if (contrastBoost > 0.0 || saturationBoost > 0.0) {
			// Calculate luminance
			float luminance = dot(resultColor.rgb, float3(0.299, 0.587, 0.114));
			
			// Enhance saturation (blend toward luminance with negative values, away with positive)
			float3 satColor = lerp(
				float3(luminance, luminance, luminance), 
				resultColor.rgb, 
				1.0 + saturationBoost
			);
			
			// Enhance contrast
			float3 contrastColor = lerp(
				satColor,
				(satColor - 0.5) * (1.0 + contrastBoost) + 0.5,
				contrastBoost * 2.0
			);
			
			// Preserve original alpha
			resultColor = float4(contrastColor, resultColor.a);
		}
		
		return resultColor;
	}

	// HLSL Code

	//--------------------------------------------------------------------------------------
	// 4-Tap Gaussian-Like Mipmap Blur
	//--------------------------------------------------------------------------------------
	// Approximates blur by sampling 4 corners around the target coordinate
	// at a selected integer mip level. Uses equal weights (Box filter at Mip level).
	//
	// Args:
	//   Tex:            Input Texture2D object with Mipmaps.
	//   Sampler:        Sampler state.
	//   TexCoord:       Base texture coordinate to sample around.
	//   BlurAmount:     Desired blur intensity [0 = sharpest, 1 = max mip blur].
	//   TextureSize:    float2 containing base width and height of the texture (Mip 0).
	//   NumMipLevels:   Total number of mip levels in the texture.
	//   KernelScale:    Adjusts the spread of the 4 taps (Optional, default ~0.7).
	//
	// Returns:
	//   Blurred float4 color.
	//--------------------------------------------------------------------------------------
	float4 MipmapGaussBlur4Tap(
		Texture2D Tex,
		SamplerState Sampler,
		float2 TexCoord,
		float BlurAmount,
		float2 TextureSize,
		uint NumMipLevels,
		float KernelScale = 0.707f) // Default scale for corner taps
	{
		// 1. Calculate target LOD and select integer level
		float maxLodIndex = max(0.0f, (float)NumMipLevels - 1.0f);
		float targetLod = maxLodIndex * saturate(BlurAmount);
		// Use round() to pick the nearest integer mip level
		float sampleLod = clamp(targetLod, 0.0f, maxLodIndex);

		// 2. Calculate effective texel size at the selected mip level
		float mipScale = exp2(sampleLod); // 2^LOD
		float2 baseTexelSize = float2(1.0f / TextureSize.x, 1.0f / TextureSize.y);
		float2 mipTexelSize = baseTexelSize * mipScale;

		// 3. Define 4 sampling offsets (rotated grid / corners)
		float2 offsets[4] = {
			float2(-0.5f, -0.5f) * mipTexelSize * KernelScale,
			float2( 0.5f, -0.5f) * mipTexelSize * KernelScale,
			float2(-0.5f,  0.5f) * mipTexelSize * KernelScale,
			float2( 0.5f,  0.5f) * mipTexelSize * KernelScale
		};

		// 4. Sample texture at the 4 offset points on the selected mip level
		float4 finalColor = float4(0.0f, 0.0f, 0.0f, 0.0f);

		// Unroll helps performance for small fixed loops
		[unroll]
		for(int i = 0; i < 4; ++i)
		{
			finalColor += Tex.SampleLevel(Sampler, TexCoord + offsets[i], sampleLod);
		}

		// 5. Average the samples (equal weights for box filter)
		finalColor *= 0.25f;

		return finalColor;
	}


	//--------------------------------------------------------------------------------------
	// 9-Tap Gaussian-Like Mipmap Blur
	//--------------------------------------------------------------------------------------
	// Approximates Gaussian blur by sampling a 3x3 grid around the target coordinate
	// at a selected integer mip level, weighting samples by a Gaussian function.
	//
	// Args:
	//   Tex:            Input Texture2D object with Mipmaps.
	//   Sampler:        Sampler state.
	//   TexCoord:       Base texture coordinate to sample around.
	//   BlurAmount:     Desired blur intensity [0 = sharpest, 1 = max mip blur].
	//   TextureSize:    float2 containing base width and height of the texture (Mip 0).
	//   NumMipLevels:   Total number of mip levels in the texture.
	//   KernelScale:    Adjusts the spread of the 9 taps (Optional, default 1.0).
	//   SigmaScale:     Adjusts Gaussian sigma relative to BlurAmount (Optional, default 1.0).
	//
	// Returns:
	//   Blurred float4 color.
	//--------------------------------------------------------------------------------------
	float4 MipmapGaussBlur9Tap(
		Texture2D Tex,
		SamplerState Sampler,
		float2 TexCoord,
		float BlurAmount,
		float2 TextureSize,
		uint NumMipLevels,
		float KernelScale = 1.0f,
		float SigmaScale = 1.0f)
	{
		// 1. Calculate target LOD and select integer level
		float maxLodIndex = max(0.0f, (float)NumMipLevels - 1.0f);
		float blurAmountSat = saturate(BlurAmount);
		float targetLod = maxLodIndex * blurAmountSat;
		// Use round() to pick the nearest integer mip level
		float sampleLod = clamp(targetLod, 0.0f, maxLodIndex);

		// 2. Calculate effective texel size at the selected mip level
		float mipScale = exp2(sampleLod); // 2^LOD
		float2 baseTexelSize = float2(1.0f / TextureSize.x, 1.0f / TextureSize.y);
		float2 mipTexelSize = baseTexelSize * mipScale;

		// 3. Calculate Gaussian weights and sample offsets for 3x3 grid
		// Use static const for grid offsets relative to center (integer)
		static const int2 gridOffsets[9] = {
			int2(-1,-1), int2(0,-1), int2(1,-1),
			int2(-1, 0), int2(0, 0), int2(1, 0),
			int2(-1, 1), int2(0, 1), int2(1, 1)
		};

		float weights[9];
		float2 sampleOffsets[9];
		float totalWeight = 0.0f;

		// Sigma can vary with blur amount for better control
		// Small sigma for low blur, larger sigma for high blur (relative to kernel size)
		float sigma = lerp(0.5f, 1.5f, blurAmountSat) * SigmaScale;
		float sigmaSq_x2 = 2.0f * sigma * sigma; // Precompute 2*sigma^2

		[unroll]
		for(int i = 0; i < 9; ++i)
		{
			float2 gridOffsetF = float2(gridOffsets[i]);
			// Calculate offset scaled by texel size at the target mip level
			sampleOffsets[i] = gridOffsetF * mipTexelSize * KernelScale;

			// Calculate Gaussian weight based on unscaled grid distance
			float distSq = dot(gridOffsetF, gridOffsetF);
			weights[i] = exp(-distSq / sigmaSq_x2);
			totalWeight += weights[i];
		}

		// Normalize weights (avoid division by zero)
		totalWeight = max(totalWeight, 1e-6f);
		float invTotalWeight = 1.0f / totalWeight;
		[unroll]
		for(int i = 0; i < 9; ++i)
		{
			weights[i] *= invTotalWeight;
		}

		// 4. Sample texture and apply weights
		float4 finalColor = float4(0.0f, 0.0f, 0.0f, 0.0f);
		[unroll]
		for(int i = 0; i < 9; ++i)
		{
			finalColor += Tex.SampleLevel(Sampler, TexCoord + sampleOffsets[i], sampleLod) * weights[i];
		}

		return finalColor;
	}

};