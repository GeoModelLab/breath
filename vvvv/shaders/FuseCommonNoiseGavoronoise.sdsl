////////////////////////////////////////////////////////////////
//
//             Random Noise Basis 
//
////////////////////////////////////////////////////////////////

shader FuseCommonNoiseGavoronoise : FuseCoreMathHash
{
    static const float PI = 3.14159265359;



    /// <summary>
    /// Gavoronoise function converted to HLSL.
    /// </summary>
    /// <param name="p">The input position coordinate.</param>
    /// <param name="dir">The direction vector for the erosion effect.</param>
    /// <returns>A float3 vector representing the noise value and its derivative.</returns>
    float3 Gavoronoise(in float2 p, in float2 dir)
    {
        float2 ip = floor(p);
        float2 fp = frac(p);

        float f = 2.0 * PI;
        float3 va = (float3)0.0; // Initialize a float3 vector to zero
        float wt = 0.0;

        // Loop over a 4x4 grid of cells
        [unroll]
        for (int i = -2; i <= 1; i++)
        {
            [unroll]
            for (int j = -2; j <= 1; j++)
            {
                float2 o = float2(i, j);
                float2 h = hash22(ip - o) * 0.5;
                float2 pp = fp + o - h;

                float d = dot(pp, pp);
                float w = exp(-d * 2.0);
                wt += w;

                float mag = dot(pp, dir);
                
                // HLSL supports constructing a float3 from a float and a float2
                va += float3(cos(mag * f), -sin(mag * f) * (pp + dir)) * w;
            }
        }

        // Return the weighted average
        return va / wt;
    }

    //This is where the magic happens
    float3 erosion(float2 p, float3 heightmap) {
        
        
        //take the curl of the normal to get the gradient facing down the slope
        float2 dir = heightmap.zy*float2(1.0, -1.0);
        
        //Now we compute another fbm type noise
        // erosion is a type of noise with a strong directionality
        //we pass in the direction based on the slope of the terrain
        //erosion also returns the slope. we add that to a running total
        //so that the direction of successive layers are based on the
        //past layers
        float3 h = float3(0.0,0.0,0.0);
        float a = 0.7*(smoothstep(0.3, 0.5,heightmap.x*0.5+0.5)); //smooth the valleys
        float f = 1.0;
        for (int i=0;i<5;i++) {
            h+= Gavoronoise(p*f, dir+h.zy*float2(1.0, -1.0))*a*float3(1.0, f, f);
            a*=0.4;
            f*=2.0;
        }
        //remap height to [0,1] and add erosion
        //looks best when erosion amount is small
        //not sure about adding the normals together, but it looks okay
        return float3(smoothstep(-1.0, 1.0, heightmap.x)+h.x*0.05, (heightmap.yz+h.yz)*0.5+0.5);
    }

};

